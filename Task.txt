{searchTerms} (siteId: {4db5bdf0-f4d9-4524-8c7a-62f986546e63} OR siteId: 4db5bdf0-f4d9-4524-8c7a-62f986546e63) (webId: {153bba80-4381-485d-b08d-3233d8cb24d3} OR webId: 153bba80-4381-485d-b08d-3233d8cb24d3) (NormListID: 67280d85-09b4-4f37-8c2b-0e42ea7a5fa1) (path: "https://mlaitechio.sharepoint.com/sites/BOB_New/Lists/CircularRepository" OR ParentLink: "https://mlaitechio.sharepoint.com/sites/BOB_New/Lists/CircularRepository*") ContentTypeId: 0x0*

kumar.v@mlaitech.io
T!151676077353ul

Count of Circular by number (Done)
Selected Tags & there value on top of search (Done)
On Click of Apply Add Department to selected Tags (Not Needed)
Clear All (Done)

Filters Accordion Icon Change

Published by Year check box with see more (Done)
Search Query ChangeEvent (Done)
Classification,Issued For,Category,Compliance, Accordion (Done)
Keywords ,Circular Number text search to be added




Mapping to be created
RefinableString08 -> IssuedFor
RefinableString09 -> Compliance


Classification Search Query string
Issued For Search Query string
Regulatory Search Query string
Category Search Query string

-------------------------------------Number of hours------------------------------------
1. Search Dashboard  --> 110 hours
2. Migration Script -> 60 hours
3. Initial Consultation & Analysis -> 8 hours
4. Download PDF with waterMark -> 25 hours
5. View PDF with watermark -> 25 hours  

Search Dashboard
1. Logic to get only published status circular items

Form
1. Bind drop down Field Values
2. Logic to implement circular number
3. Logic to set state of a field on change
4. Logic for My Request & Compliance 
5. Logic to save item as Draft
6. Logic to submit item 
7. Logic to implement comments history
8. Logic to implement checker history.
9. Logic to disable fields
10.Logic to update item
11.Logic to show attachment preview section & have the ability to edit item
12.Permission handling of item
13. Working on it Logic
14. Success message logic

supporting documents > list of circulars will be of specific department (multiple check box)


// let users = await this.context.msGraphClientFactory.getClient("3").then((client: MSGraphClientV3) => {
        //     // get information about the current user from the Microsoft Graph
        //     return client
        //         .api('/users')
        //         .get((error, response: any[], rawResponse?: any) => {
        //             return Promise.resolve(response)
        //         });
        // }).catch((error) => {
        //     return Promise.reject(error);
        // });

await services.getPagedListItems(serverRelativeUrl,
        Constants.circularList, Constants.colCircularRepository, `${Constants.filterString}`,
        Constants.expandColCircularRepository, 'PublishedDate', false).then(async (value: ICircularListItem[]) => {

          const listItems = value?.filter((val) => {
            return val.CircularStatus == Constants.published;
          })

          const uniqueDepartment: any[] = [...new Set(listItems.map((item) => {
            return item.Department;
          }))].sort((a, b) => a < b ? -1 : 1);

          const uniquePublishedYear: any[] = [...new Set(listItems.map((item) => {
            return new Date(item.PublishedDate).getFullYear().toString();
          }))];

          this.setState({
            items: listItems,
            filteredItems: listItems,
            departments: uniqueDepartment?.filter((option) => {
              return option != undefined
            }),
            publishedYear: uniquePublishedYear
          }, () => {
            let checkBoxCollection = this.initializeCheckBoxFilter();
            this.setState({ checkBoxCollection: checkBoxCollection, isLoading: false }, () => {
              this.setState({ filterPanelCheckBoxCollection: checkBoxCollection })
            });
          })
        }).catch((error) => {
          console.log(error);
          this.setState({ isLoading: false })
        });

{/* <Field label={<FluentLabel weight="semibold" style={{ fontFamily: "Roboto" }}>{`Published To Date`}</FluentLabel>}>
                <DatePicker mountNode={{}}
                  formatDate={this.onFormatDate}
                  value={publishedEndDate}
                  contentAfter={
                    <>
                      <FluentUIBtn
                        icon={<ArrowCounterclockwiseRegular />}
                        appearance="transparent" title="Reset"
                        onClick={this.onResetClick.bind(this, `ToDate`)}>
                      </FluentUIBtn>
                      <FluentUIBtn icon={<CalendarRegular />} appearance="transparent"></FluentUIBtn>

                    </>}
                  onSelectDate={this.onSelectDate.bind(this, `ToDate`)}
                  input={{ style: { fontFamily: "Roboto" } }} />
              </Field> */}

              {/* <Input input={{ readOnly: true, type: "date" }} root={{ style: { fontFamily: "Roboto" } }}></Input> */}

                {/* <DatePicker mountNode={{}}
                  formatDate={this.onFormatDate}
                  value={publishedStartDate}
                  contentAfter={
                    <>
                      <FluentUIBtn icon={<ArrowCounterclockwiseRegular />}
                        appearance="transparent"
                        title="Reset"
                        onClick={this.onResetClick.bind(this, `FromDate`)}>
                      </FluentUIBtn>
                      <FluentUIBtn icon={<CalendarRegular />} appearance="transparent"></FluentUIBtn>
                    </>}
                  onSelectDate={this.onSelectDate.bind(this, `FromDate`)}
                  input={{ style: { fontFamily: "Roboto" } }} /> */}

{/* <Field label={<FluentLabel weight="semibold" style={{ fontFamily: "Roboto" }}>{`Department`}</FluentLabel>}>
              <Dropdown mountNode={{}} placeholder="Select Department" value={selectedDepartment[0]}
                selectedOptions={selectedDepartment}
                onOptionSelect={this.onDropDownChange.bind(this, "Department")}>
                {departments && departments.length > 0 && departments.map((val) => {
                  return <><Option key={`${val}`}>{val}</Option></>
                })}
              </Dropdown>
            </Field> */}

            //advanceFilterString += `${filterArray[0]}`;
        //advanceFilterString += `and((${filterArray[0]}))`;// ,${searchTextRefinment}//or(${searchTextRefinment}))



        import * as React from 'react'
import styles from './CircularSearch.module.scss';
import styles1 from '../BobCircularRepository.module.scss';
import {
  DefaultButton, DetailsList, DetailsListLayoutMode, DetailsRow, DialogContent, getResponsiveMode,
  IColumn, Icon, IDetailsListProps, IDetailsRowStyles,
  Image, Label, PrimaryButton, SearchBox, SelectionMode, Stack
} from '@fluentui/react';
import {
  Checkbox,
  CheckboxOnChangeData,
  Dropdown,
  Field, Label as FluentLabel,
  Input,
  OptionOnSelectData,
  Option, Button as FluentUIBtn,
  SelectionEvents,
  Switch,
  SwitchOnChangeData,
  Tag,
  Avatar,
  InputOnChangeData,
} from "@fluentui/react-components";
import { DatePicker } from "@fluentui/react-datepicker-compat";
import { ICircularSearchProps } from './ICircularSearchProps';
import { ICircularSearchState } from './ICircularSearchState';
import { Constants } from '../../Constants/Constants';
import { Badge, Dialog, DialogBody, DialogSurface, Spinner } from '@fluentui/react-components';
import {
  TagPicker,
  TagPickerList,
  TagPickerInput,
  TagPickerControl,
  TagPickerProps,
  TagPickerOption,
  TagPickerGroup,
} from "@fluentui/react-components";
import { IBobCircularRepositoryProps } from '../IBobCircularRepositoryProps';
import Pagination from 'react-js-pagination';
import { DataContext } from '../../DataContext/DataContext';
import FileViewer from '../FileViewer/FileViewer';
import { AddCircleRegular, ArrowClockwise24Regular, ArrowClockwiseRegular, ArrowCounterclockwiseRegular, Attach12Filled, CalendarRegular, DismissRegular, FilterRegular } from '@fluentui/react-icons';

export default class CircularSearch extends React.Component<ICircularSearchProps, ICircularSearchState> {

  static contextType = DataContext;
  context!: React.ContextType<typeof DataContext>;

  constructor(props) {
    super(props)

    const columns: IColumn[] = [{
      key: 'Subject',
      name: 'Subject',
      fieldName: 'Subject',
      minWidth: 200,
      maxWidth: 450,
      isMultiline: true,
      isRowHeader: true,
      isResizable: true,
      data: 'string',
      styles: { cellName: { width: "100%" } },
      // isPadded: true,
      isSorted: false,
      isSortedDescending: true,
      sortAscendingAriaLabel: 'Sorted A to Z',
      sortDescendingAriaLabel: 'Sorted Z to A',
      onColumnClick: this.handleSorting(`${Constants.colSubject}`),
      headerClassName: styles.header,
      onRender: this.createHyper.bind(this)
    },
    {
      key: 'PublishedDate',
      name: 'Published Date',
      fieldName: 'PublishedDate',
      minWidth: 150,
      maxWidth: 200,
      // isCollapsible: true,
      isResizable: true,
      data: 'string',
      // isPadded: true,
      headerClassName: styles.header,
      styles: { cellName: { width: "100%", textAlign: "center" } },
      isSorted: false,
      isSortedDescending: true,
      sortAscendingAriaLabel: 'Sorted A to Z',
      sortDescendingAriaLabel: 'Sorted Z to A',
      onColumnClick: this.handleSorting(`${Constants.colPublishedDate}`),
      onRender: this.renderDate.bind(this)

    },
    {
      key: 'MigratedDepartment',
      name: 'Department',
      fieldName: 'MigratedDepartment',
      minWidth: 200,
      maxWidth: 400,
      isResizable: true,
      data: 'string',
      isSorted: false,
      isSortedDescending: false,
      sortAscendingAriaLabel: 'Sorted A to Z',
      sortDescendingAriaLabel: 'Sorted Z to A',
      styles: { cellName: { width: "100%" } },
      headerClassName: styles.header,
      onColumnClick: this.handleSorting(`${Constants.colCircularNumber}`)
      // isPadded: true,
      //onRender: this.renderCategory.bind(this)
    },
    {
      key: 'CircularNumber',
      name: 'Circular Number',
      fieldName: 'CircularNumber',
      minWidth: 100,
      maxWidth: 150,
      isResizable: true,
      data: 'string',
      isSorted: false,
      isSortedDescending: false,
      sortAscendingAriaLabel: 'Sorted A to Z',
      sortDescendingAriaLabel: 'Sorted Z to A',
      styles: { cellName: { width: "100%" } },
      headerClassName: styles.header,
      onColumnClick: this.handleSorting(`${Constants.colCircularNumber}`)
      // isPadded: true,
      //onRender: this.renderCategory.bind(this)
    },
    {
      key: 'Classification',
      name: 'Classification',
      fieldName: 'Classification',
      minWidth: 100,
      maxWidth: 150,
      isResizable: true,
      data: 'string',
      isSorted: false,
      isSortedDescending: false,
      sortAscendingAriaLabel: 'Sorted A to Z',
      sortDescendingAriaLabel: 'Sorted Z to A',
      styles: { cellName: { width: "100%" } },
      headerClassName: styles.header,
      onColumnClick: this.handleSorting(`${Constants.colClassification}`),
      // isPadded: true,
      //onRender: this.renderTextField.bind(this)
    }]

    this.state = {
      searchText: "",
      items: [],
      filteredItems: [],
      columns,
      currentPage: 1,
      itemsPerPage: 10,
      isLoading: false,
      departments: [],
      selectedDepartment: [],
      circularNumber: ``,
      checkCircularRefiner: `Contains`,
      circularRefinerOperator: ``,
      switchSearchText: `Normal Search`,
      isNormalSearch: true,
      sortDirection: 'desc',
      sortingFields: `${Constants.colPublishedDate}`,
      publishedStartDate: null,
      publishedEndDate: null,
      previewItems: undefined
    }


  }

  public componentDidMount() {
    let providerValue = this.context;
    const { context, services, serverRelativeUrl, userDisplayName } = providerValue as IBobCircularRepositoryProps;

    this.setState({ isLoading: true }, async () => {
      await services.getPagedListItems(serverRelativeUrl,
        Constants.circularList, Constants.colCircularRepository, ``,
        Constants.expandColCircularRepository, 'PublishedDate', false).then((value) => {

          const uniqueDepartment: any[] = [...new Set(value.map((item) => {
            return item.Department;
          }))];

          this.setState({
            items: value, filteredItems: value, departments: uniqueDepartment.filter((option) => {
              return option != undefined
            })
          }, () => {
            this.setState({ isLoading: false });
          })
        }).catch((error) => {
          console.log(error);
          this.setState({ isLoading: false })
        })
    })
  }

  public render() {

    let providerValue = this.context;
    const { context, services, serverRelativeUrl, circularListID } = providerValue as IBobCircularRepositoryProps;
    const { onAddNewItem } = this.props
    const responsiveMode = getResponsiveMode(window);
    let mobileMode = responsiveMode == 0 || responsiveMode == 1 || responsiveMode == 2;
    let searchBoxColumn = mobileMode ? `${styles1.column12}` : `${styles1.column10}`;
    let searchClearColumn = mobileMode ? `${styles1.column12} ${styles1.textAlignEnd}` : `${styles1.column2}`;
    const { filteredItems, previewItems, circularNumber, isLoading, isNormalSearch, switchSearchText, publishedStartDate, publishedEndDate } = this.state;

    let detailListClass = mobileMode ? `${styles1.column12}` : `${styles1.column12}`;

    return (<>

      {
        isLoading && this.workingOnIt()
      }

      <div className={`${styles.row} ${styles1.search}`} style={{ marginTop: 10 }}>

        <div className={`${styles1.column12} `}>
          <div className={`${styles.row}`}>
            <Label className={`${styles1.column10}`} styles={{ root: { color: "#f26522", fontFamily: 'Roboto' } }}>
              {Constants.hindiSearchCircular} : {Constants.engSearchCircular}
            </Label>
            {/* <div className={`${styles1.column2}`} style={{ marginTop: 3 }}>
              <FluentUIBtn appearance="primary" icon={<AddCircleRegular />} iconPosition="before" onClick={onAddNewItem}>Create Circular</FluentUIBtn>
            </div> */}
          </div>

          <Label styles={{ root: { textDecoration: "underline", padding: 0, fontFamily: 'Roboto' } }} className={`${styles1['text-center']}`}>
            {Constants.hindiSearchHeader}
          </Label>
        </div>
        <div className={`${styles1.column12}`}>
          <Label styles={{ root: { textDecoration: "underline", padding: 0, fontFamily: 'Roboto' } }} className={`${styles1['text-center']}`}>
            {Constants.engSearchHeader}
          </Label>
        </div>
        <div className={`${searchBoxColumn} ${styles1.marginTop}`}>
          {this.searchBox()}
        </div>
        <div className={`${searchClearColumn} ${styles1.marginTop} `} >
          <Switch
            label={<FluentLabel weight="semibold" style={{ fontFamily: "Roboto" }}>{switchSearchText}</FluentLabel>}
            onChange={this.onSwitchChange}
          />
        </div>


        {!isNormalSearch && <>
          <div className={`${styles1.column4}  ${styles1.marginTop}`}>
            {this.pickerControl()}
            
          </div>
          <div className={`${styles1.column3} ${styles1.marginTop}`}>
            <Field label={<FluentLabel weight="semibold" style={{ fontFamily: "Roboto" }}>{`Circular Number`}</FluentLabel>} ></Field>
            <div className={`${styles1.row}`}>
              <div className={`${styles1.column4}`}>
                {this.checkBoxControl(`Contains`)}
              </div>
              <div className={`${styles1.column8}`} style={{ padding: 0 }}>

                <Input placeholder="Input at least 2 characters"
                  input={{ className: `${styles.input}` }}
                  className={`${styles.input}`}
                  value={circularNumber}
                  onChange={this.onInputChange} />
              </div>
              <div className={`${styles1.column12}`}>
                {this.checkBoxControl(`Starts With`)}
              </div>

              <div className={`${styles1.column12}`}>
                {this.checkBoxControl(`Ends With`)}
              </div>
            </div>
          </div>
          {/* <div className={`${styles1.column1}`}></div> */}

          <div className={`${styles1.column3} ${styles1.marginTop}`}>
            <Field label={<FluentLabel weight="semibold" style={{ fontFamily: "Roboto" }}>{`Published From Date`}</FluentLabel>} >
              {/* <Input input={{ readOnly: true, type: "date" }} root={{ style: { fontFamily: "Roboto" } }}></Input> */}

              <DatePicker mountNode={{}}
                formatDate={this.onFormatDate}
                value={publishedStartDate}
                contentAfter={
                  <>
                    <FluentUIBtn icon={<ArrowCounterclockwiseRegular />}
                      appearance="transparent"
                      title="Reset"
                      onClick={this.onResetClick.bind(this, `FromDate`)}>
                    </FluentUIBtn>
                    <FluentUIBtn icon={<CalendarRegular />} appearance="transparent"></FluentUIBtn>
                  </>}
                onSelectDate={this.onSelectDate.bind(this, `FromDate`)}
                input={{ style: { fontFamily: "Roboto" } }} />


            </Field>
            <Field label={<FluentLabel weight="semibold" style={{ fontFamily: "Roboto" }}>{`Published To Date`}</FluentLabel>}>
              <DatePicker mountNode={{}}
                formatDate={this.onFormatDate}
                value={publishedEndDate}
                contentAfter={
                  <>
                    <FluentUIBtn
                      icon={<ArrowCounterclockwiseRegular />}
                      appearance="transparent" title="Reset"
                      onClick={this.onResetClick.bind(this, `ToDate`)}>
                    </FluentUIBtn>
                    <FluentUIBtn icon={<CalendarRegular />} appearance="transparent"></FluentUIBtn>

                  </>}
                onSelectDate={this.onSelectDate.bind(this, `ToDate`)}
                input={{ style: { fontFamily: "Roboto" } }} />
            </Field>
          </div>
        </>}

        <div className={`${styles1.column12} ${styles1.marginTop} ${styles1['text-center']}`}>
          {this.searchClearButtons()}
        </div>
      </div >
      <div className={`${styles.row}`}>
        <div className={`${detailListClass}`} style={{ padding: 15 }}>
          {this.circularSearchResultsTable()}
        </div>
      </div>
      {
        <div className={`${styles1.row}`}>
          <div className={`${styles1.column12}`}>
            {!isLoading && filteredItems.length == 0 && this.noItemFound()}
          </div>
        </div>
      }

      {
        previewItems &&
        <div className={`${styles1.row}`}>
          <FileViewer listItem={previewItems}
            stateKey={new Date().toISOString()}
            context={context} onClose={this.onPanelClose}
            onUpdate={this.updateItem}></FileViewer>
        </div>
      }

    </>
    )
  }

  private checkBoxControl = (labelName): JSX.Element => {
    const { checkCircularRefiner } = this.state
    let checkBoxJSX = <>
      <Checkbox
        checked={checkCircularRefiner == labelName}
        label={<FluentLabel weight="semibold" style={{ fontFamily: "Roboto" }}>{labelName}</FluentLabel>}
        shape="circular" size="medium" onChange={this.onCheckBoxChange.bind(this, labelName)} />
    </>

    return checkBoxJSX;
  }


  private onResetClick = (labelName: string) => {
    switch (labelName) {
      case `FromDate`: this.setState({ publishedStartDate: null });
        break;
      case `ToDate`: this.setState({ publishedEndDate: null });
        break;

    }
  }



  private onCheckBoxChange = (labelName: string, ev: React.ChangeEvent<HTMLInputElement>, data: CheckboxOnChangeData) => {
    switch (labelName) {
      case `Contains`: this.setState({ checkCircularRefiner: labelName, circularRefinerOperator: `` });
        break;
      case `Starts With`: this.setState({ checkCircularRefiner: labelName, circularRefinerOperator: `starts-with` });
        break;
      case `Ends With`: this.setState({ checkCircularRefiner: labelName, circularRefinerOperator: `ends-with` });
        break;
    }
  }

  private onSwitchChange = (ev: React.ChangeEvent<HTMLInputElement>, data: SwitchOnChangeData) => {
    if (data.checked) {
      this.setState({ isNormalSearch: false, switchSearchText: `Advanced Search` })
    }
    else {
      this.setState({ isNormalSearch: true, switchSearchText: `Normal Search` })
    }
  }

  private pickerControl = (): JSX.Element => {
    const { departments, selectedDepartment } = this.state
    var pickerJSX = <>
      <Field label={<FluentLabel weight="semibold"
        style={{ fontFamily: "Roboto" }}>{`Select Department`}</FluentLabel>} >
        <TagPicker

          onOptionSelect={this.onOptionSelect}
          selectedOptions={selectedDepartment}
        >
          <TagPickerControl >
            <TagPickerGroup>
              {selectedDepartment.map((option) => (
                <Tag
                  primaryText={{ style: { fontFamily: "Roboto", fontWeight: 600 } }}
                  key={option}
                  shape="rounded"
                  size="small"

                  // media={<Avatar aria-hidden name={option} color="colorful" />}
                  value={option}
                >
                  {option}
                </Tag>
              ))}
            </TagPickerGroup>
            <TagPickerInput aria-label="Select Employees" />
          </TagPickerControl>
          <TagPickerList >
            {departments.length > 0
              ? departments.filter((option) => {
                if (selectedDepartment[0] !== option) {
                  return option;
                }

              }).map((option) => (
                <TagPickerOption
                  style={{ fontFamily: "Roboto", fontWeight: 600 }}
                  value={option}
                  key={option}>
                  {option}
                </TagPickerOption>
              ))
              : "No options available"}
          </TagPickerList>
        </TagPicker>
      </Field>
    </>

    return pickerJSX;
  }

  private onOptionSelect: TagPickerProps["onOptionSelect"] = (e, data) => {

    if (data.selectedOptions.length > 0) {
      this.setState({ selectedDepartment: [data.value] })
    }
    else {
      this.setState({ selectedDepartment: [] })
    }


  }

  private onInputChange = (ev: React.ChangeEvent<HTMLInputElement>, data: InputOnChangeData) => {
    this.setState({ circularNumber: data.value });
  }

  private onSelectDate = (labelName: string, date: Date | null) => {
    switch (labelName) {
      case `FromDate`: this.setState({ publishedStartDate: date });
        break;
      case `ToDate`: this.setState({ publishedEndDate: date });
        break;
    }

  }

  private onDropDownChange = (textLabel: string, event: SelectionEvents, data: OptionOnSelectData) => {

  }

  private onFormatDate = (date?: Date): string => {
    return !date
      ? ""
      : (date.getDate() < 9 ? (`0` + date.getDate()) : date.getDate()) +
      "/" +
      ((date.getMonth() + 1 < 9 ? (`0${date.getMonth() + 1}`) : date.getMonth() + 1)) +
      "/" +
      (date.getFullYear());
  };

  private updateItem = (itemID: any) => {
    this.props.onUpdateItem(itemID)
  }

  private onPanelClose = () => {
    this.setState({ previewItems: null })
  }

  private searchClearButtons = (): JSX.Element => {
    let searchClearJSX = <>
      <FluentUIBtn appearance="primary" style={{ marginRight: 5 }} icon={<FilterRegular />} onClick={() => { this.searchResults() }}>
        Search
      </FluentUIBtn>
      <FluentUIBtn appearance="secondary" icon={<DismissRegular />} onClick={() => { this.clearFilters() }}>
        Clear
      </FluentUIBtn>
    </>;

    return searchClearJSX;

  }

  private searchBox = (): JSX.Element => {
    const { searchText } = this.state;
    let searchBoxJSX =
      <Stack tokens={{ childrenGap: 20 }}>
        <SearchBox
          placeholder={`${Constants.searchText} `}
          onChange={this.onSearchBoxChange}
          onSearch={this.handleSearch}
          //onClear={(ev?: any) => { this.onClear() }}
          onClear={(ev?: any) => { this.onSearchClear() }}
          defaultValue={searchText}
          value={searchText}
          styles={{
            root: {
              border: "1px solid #bac6f7",
              fontFamily: "Roboto",
              borderRadius: 5,
              ":hover": {
                borderColor: "1px solid #bac6f7"
              },
              ".is-active": {
                border: "1px solid #bac6f7"
              }
            }
          }}
        />
      </Stack>;

    return searchBoxJSX;
  }

  private onSearchBoxChange = (event?: React.ChangeEvent<HTMLInputElement>, newValue?: string) => {
    this.setState({ searchText: newValue })
  }

  private handleSearch = (newValue?: string) => {

    this.searchResults(newValue)

  }

  private onSearchClear = () => {
    this.setState({ searchText: `` })
  }

  private searchResults = (newValue?: string) => {
    let providerValue = this.context;
    const { context, services, serverRelativeUrl, circularListID } = providerValue as IBobCircularRepositoryProps;

    let siteID = context.pageContext.site.id;
    let webID = context.pageContext.web.id;
    let siteURL = context.pageContext.site.absoluteUrl;

    this.setState({ isLoading: true }, async () => {

      let listItemData: any[] = [];
      let searchProperties = Constants.selectedSearchProperties;
      const { searchText, sortingFields, sortDirection } = this.state
      let queryTemplate = `{searchTerms} (siteId: {${siteID}} OR siteId: ${siteID}) (webId: {${webID}} OR webId: ${webID}) (NormListID: ${circularListID}) `;
      queryTemplate += `(path: "${siteURL}/Lists/${Constants.circularList}" OR ParentLink: "${siteURL}/Lists/${Constants.circularList}*") ContentTypeId: 0x0* `;

      let refinableFilterQuery = this.refinableQuery();
      let searchTextAndFilterQuery = this.searchQueryAndFilterQuery();
      let sortListProperty = [{
        Property: Constants.managePropPublishedDate,
        Direction: 1 //0 for asc & 1 for descending
      }]

      /**
      |--------------------------------------------------
      | This is to search text using Refinment filters ex: RefinableString00:${queryText}*,.. 
      |--------------------------------------------------
      */
      if (searchTextAndFilterQuery != "") {

        await services.getSearchResults('', searchProperties, queryTemplate, searchTextAndFilterQuery, sortListProperty).
          then(async (searchResults: any[]) => {

            searchResults.map((val) => {

              listItemData.push({
                Id: parseInt(val.ListItemID),
                Created: val?.Created,
                CircularNumber: val.RefinableString00,
                Subject: val.RefinableString01,
                MigratedDepartment: val.RefinableString02,
                Department: val.RefinableString03,
                Category: val.RefinableString04,
                IsMigrated: val.RefinableString05,
                Classification: val.RefinableString06,
                PublishedDate: val.RefinableDate00,

              })

            })

          }).catch((error) => {
            console.log(error);
            this.setState({ isLoading: false })
          });
      }

      /**
      |--------------------------------------------------
      | This is to search content inside Metadata & attachments with query text
      |--------------------------------------------------
      */
      await services.
        getSearchResults(searchText.trim() == '' ? `` : searchText, searchProperties, queryTemplate, refinableFilterQuery, sortListProperty).
        then(async (searchResults: any[]) => {
          searchResults.map((val) => {

            listItemData.push({
              Id: parseInt(val.ListItemID),
              Created: val?.Created,
              CircularNumber: val.RefinableString00,
              Subject: val.RefinableString01,
              MigratedDepartment: val.RefinableString02,
              Department: val.RefinableString03,
              Category: val.RefinableString04,
              IsMigrated: val.RefinableString05,
              Classification: val.RefinableString06,
              PublishedDate: val.RefinableDate00,

            })

          })
        }).catch((error) => {
          console.log(error);
          this.setState({ isLoading: false })
        });

      let uniqueResults = searchTextAndFilterQuery != "" ? [...new Map(listItemData.map(item =>
        [item["Id"], item])).values()] : listItemData;

      let searchFilterItems = uniqueResults.filter((val) => { return val !== undefined });

      this.setState({
        filteredItems: this.sortListItems(searchFilterItems, sortingFields, sortDirection),
        searchItems: searchFilterItems, currentPage: 1, isLoading: false
      })

    });

  }


  private sortListItems(listItems: any[], sortingFields, sortDirection) {

    const isDesc = sortDirection === 'desc' ? 1 : -1;
    // let sortFieldDetails = this.props.fields.filter(f => f.key === sortingFields)[0];

    switch (sortingFields) {

      case Constants.colPublishedDate: let sortFn: (a, b) => number;
        sortFn = (a, b) => ((new Date(a[sortingFields]).getTime() < new Date(b[sortingFields]).getTime()) ? 1 : -1) * isDesc;
        listItems.sort(sortFn);
        break;
      case Constants.colSubject: sortFn = (a, b) => ((a[sortingFields] > b[sortingFields]) ? 1 : -1) * isDesc;
        listItems.sort(sortFn);
        break;
      case Constants.colMigratedDepartment: sortFn = (a, b) => ((a[sortingFields] > b[sortingFields]) ? 1 : -1) * isDesc;
        listItems.sort(sortFn);
        break;
      case Constants.colCircularNumber: sortFn = (a, b) => ((a[sortingFields] > b[sortingFields]) ? 1 : -1) * isDesc;
        listItems.sort(sortFn);
        break;
      case Constants.colClassification: sortFn = (a, b) => ((a[sortingFields] > b[sortingFields]) ? 1 : -1) * isDesc;
        listItems.sort(sortFn);
        break;

    }

    return listItems;
  }

  private handleSorting = (property: string) => (event: React.MouseEvent<unknown>, column: IColumn) => {
    property = column.key;

    this.setState({ sortingFields: column.key }, () => {
      let { sortingFields, sortDirection, filteredItems } = this.state;
      //const isDesc = sortingFields && sortingFields === property && sortDirection === 'desc';
      const isDesc = property && sortingFields === property && sortDirection === 'desc';
      let updateColumns = this.state.columns.map(c => {
        //isSortedDescending: (isAsc ? false : true)
        //return c.key === property ? { ...c, isSorted: true, isSortedDescending: (isDesc ? false : true) } : { ...c };
        if (c.key == Constants.colPublishedDate) {
          return c.key === property ? { ...c, isSorted: true, isSortedDescending: !isDesc } : { ...c, isSorted: false, isSortedDescending: !c.isSortedDescending };
        }
        else {
          return c.key === property ? { ...c, isSorted: true, isSortedDescending: !c.isSortedDescending } : { ...c, isSorted: false, isSortedDescending: !c.isSortedDescending };
        }

      });

      this.setState({
        sortDirection: (isDesc ? 'asc' : 'desc'),
        sortingFields: property,
        columns: updateColumns,
      }, () => {
        const { sortDirection, sortingFields } = this.state;
        this.setState({ filteredItems: this.sortListItems(filteredItems, sortingFields, sortDirection) })
      });
    })

  }


  private circularSearchResultsTable = (): JSX.Element => {

    const { filteredItems } = this.state
    let filteredPageItems = this.paginateFn(filteredItems);
    const { columns } = this.state
    let searchResultsJSX = <>
      {this.detailListView(filteredPageItems, columns)}
    </>

    return searchResultsJSX;

  }


  private searchQueryAndFilterQuery = (): string => {

    const { selectedDepartment, searchText, isNormalSearch, circularNumber, circularRefinerOperator,
      publishedStartDate, publishedEndDate } = this.state;

    /**
    |--------------------------------------------------
    |  | RefinableString00 -> CircularNumber
        RefinableString01 -> Subject
        RefinableString02 -> Migrated Department
        RefinableString03 -> Department
        RefinableString04 -> Category
        RefinableString05 -> IsMigrated 
        RefinableString06 -> Classification
        RefinableDate00 -> PublishedDate 
    |--------------------------------------------------
    */
    let departmentVal = selectedDepartment[0] ?? ``;//RefinableString03
    let circularVal = circularNumber != "" ? circularNumber : ``;
    let publishedStartVal = publishedStartDate?.toISOString() ?? ``;//RefinableDate00
    let publishedEndVal = publishedEndDate?.toISOString() ?? ``;

    let filterArray = [];

    let advanceFilterString = "";

    let filterProperties = Constants.filterSearchProperties;

    let searchTextRefinment = this.searchQuery(searchText);


    if (!isNormalSearch) {
      `${departmentVal != "" ? filterArray.push(`${filterProperties[3]}:equals("${departmentVal}")`) : ``} `;
      `${circularVal != "" ? filterArray.push(`${filterProperties[0]}:${circularRefinerOperator}("${circularVal}*")`) : ``} `;
      if (publishedStartVal != "" && publishedEndVal != "") {
        filterArray.push(`${filterProperties[4]}: range(${publishedStartVal.split('T')[0]}T23:59:59Z, ${publishedEndVal.split('T')[0]}T23:59:59Z)`)
      }
    }

    if (filterArray.length > 1) {
      if (searchTextRefinment != "") {
        //advanceFilterString += `and(${filterArray.join(',')})`;// ${searchTextRefinment}//,or(${searchTextRefinment}))
        advanceFilterString += `and(${filterArray.join(',')},${searchTextRefinment})`;
      }
      else {
        advanceFilterString += `and(${filterArray.join(',')})`
      }
    }
    else if (filterArray.length == 1) {
      if (searchTextRefinment != "") {
        advanceFilterString += `and((${filterArray[0]}),${searchTextRefinment})`;
        //advanceFilterString += `${filterArray[0]}`;
        //advanceFilterString += `and((${filterArray[0]}))`;// ,${searchTextRefinment}//or(${searchTextRefinment}))
      }
      else {
        advanceFilterString += filterArray[0];
      }

    }
    else {
      if (searchTextRefinment != "") {
        advanceFilterString += `${searchTextRefinment}`;
      }
      else {
        advanceFilterString += ``;
      }

    }

    console.log(advanceFilterString)

    return advanceFilterString

  }

  private searchQuery = (searchText): string => {

    let subject = Constants.managePropSubject;
    let queryTextFilters = [];
    let refinmentString = "";

    if (searchText && searchText.trim() != "") {
      queryTextFilters = searchText.trim().split(' ');
      if (queryTextFilters.length > 1) {

        let queryText = [];
        queryTextFilters.map((word) => {
          queryText.push(`"${word}*"`)
        })
        refinmentString = `${subject}: or(` + queryText.join(',') + `)`;

        // refinmentString += `, ${department}: or(`
        // queryText = "";

        // queryTextFilters.map((word) => {
        //   queryText += `"${word}*", `
        // })

        //  refinmentString += queryText.substring(0, queryText.length - 1) + `)`;

        // refinmentString += `, ${ circularNumber }: or(`;
        // queryText = "";
        // queryTextFilters.map((word) => {
        //   queryText += `"${word}*", `
        // })
        // refinmentString += queryText.substring(0, queryText.length - 1) + `)`;

      }

      else {
        refinmentString += `${subject}: "${queryTextFilters[0]}*"`; //,${documentNo}:"${queryTextFilters[0]}*",${keywords}:"${queryTextFilters[0]}*"
      }
    }

    return refinmentString;

  }

  private refinableQuery = () => {
    const { selectedDepartment, searchText, isNormalSearch, circularNumber, circularRefinerOperator,
      publishedStartDate, publishedEndDate } = this.state;

    /**
    |--------------------------------------------------
    |  | RefinableString00 -> CircularNumber
        RefinableString01 -> Subject
        RefinableString02 -> Migrated Department
        RefinableString03 -> Department
        RefinableString04 -> Category
        RefinableString05 -> IsMigrated 
        RefinableString06 -> Classification
        RefinableDate00 -> PublishedDate 
    |--------------------------------------------------
    */
    let departmentVal = selectedDepartment[0] ?? ``;//RefinableString03
    let circularVal = circularNumber != "" ? circularNumber : ``;
    let publishedStartVal = publishedStartDate?.toISOString() ?? ``;//RefinableDate00
    let publishedEndVal = publishedEndDate?.toISOString() ?? ``;

    let filterArray = [];

    let advanceFilterString = "";

    let filterProperties = Constants.filterSearchProperties;

    let searchTextRefinment = this.searchQuery(searchText);


    if (!isNormalSearch) {
      `${departmentVal != "" ? filterArray.push(`${filterProperties[3]}:equals("${departmentVal}")`) : ``} `;
      `${circularVal != "" ? filterArray.push(`${filterProperties[0]}:${circularRefinerOperator}("${circularVal}*")`) : ``} `;
      if (publishedStartVal != "" && publishedEndVal != "") {
        filterArray.push(`${filterProperties[4]}: range(${publishedStartVal.split('T')[0]}T23:59:59Z, ${publishedEndVal.split('T')[0]}T23:59:59Z)`)
      }
    }

    if (filterArray.length > 1) {
      if (searchTextRefinment != "") {
        advanceFilterString += `and(${filterArray.join(',')})`;//, ${searchTextRefinment}
      }
      else {
        advanceFilterString += `and(${filterArray.join(',')})`;
      }
    }
    else if (filterArray.length == 1) {
      if (searchTextRefinment != "") {
        //advanceFilterString += `and((${filterArray[0]}),or(${searchTextRefinment}))`
        advanceFilterString += `${filterArray[0]}`;
      }
      else {
        advanceFilterString += filterArray[0];
      }

    }
    else {
      advanceFilterString += ``
    }

    console.log(advanceFilterString)

    return advanceFilterString


  }


  private detailListView = (filteredPageItems, columns): JSX.Element => {
    let detailListViewJSX =
      <>
        <DetailsList
          className={` ${styles1.detailsListBorderRadius} `}
          styles={{
            root: {
              ".ms-DetailsHeader-cell": {

                ".ms-DetailsHeader-cellTitle": {
                  color: "white",
                  ".ms-Icon": {
                    color: "white",
                    fontWeight: 600,
                    left: -30
                  }
                }
              },
              ".ms-DetailsHeader-cell:hover": {

                background: "#f26522",
                color: "white",
                cursor: "pointer"
              }
            },
            focusZone: {
              ".ms-List": {
                ".ms-List-surface": {
                  ".ms-List-page": {
                    ".ms-List-cell": {
                      ".ms-DetailsRow": {

                        borderBottom: "1px solid #ccc",

                        ".ms-DetailsRow-fields": {
                          ".ms-DetailsRow-cell": {
                            fontWeight: 400,
                            fontSize: "13.5px",
                            fontFamily: 'Roboto',
                            color: "black"
                          }
                        }
                      },
                      ".ms-DetailsRow:hover": {
                        borderBottom: "1px solid #ccc",
                        background: "#f265221a"
                      }
                    }
                  }
                }
              }
            },
            headerWrapper: {
              ".ms-DetailsHeader": {
                color: "white",//"#003171",
                paddingTop: 0,
                backgroundColor: "#f26522"//"#495057" //"rgb(225 234 244)"//"#EEEFF0" //"#5581F6"//"rgb(3, 120, 124)"
              }
            }
          }}
          items={filteredPageItems}
          columns={columns}
          compact={true}
          selectionMode={SelectionMode.none}
          getKey={this._getKey}
          setKey="none"
          layoutMode={DetailsListLayoutMode.fixedColumns}
          isHeaderVisible={true}
          onItemInvoked={this._onItemInvoked}
          onRenderRow={this._onRenderRow}

        // onRenderDetailsHeader={(props, defaultRender) =>
        //   defaultRender({ ...props, styles: { root: { width: 200 } } })
        // }
        // onRenderDetailsFooter={this.createPagination.bind(this)}
        />
        {this.createPagination()}

      </>

    return detailListViewJSX;
  }

  private paginateFn = (filterItem: any[]) => {
    let { itemsPerPage, currentPage } = this.state;
    return (itemsPerPage > 0
      ? filterItem ? filterItem.slice((currentPage - 1) * itemsPerPage, (currentPage - 1) * itemsPerPage + itemsPerPage) : filterItem
      : filterItem
    );
  }

  private noItemFound = (): JSX.Element => {
    let noItemFoundJSX = <>

      <div className={`${styles1.OneUpError} `}>
        <div className={`${styles1.odError} `}>
          {/* <div className={`${ styles1.odErrorImage } `}>
            <Image src={require('../../assets/error2.svg')}
              styles={{
                root: {
                  display: 'inline-flex',
                  height: 230
                }
              }}></Image>
          </div> */}
          <div className={`${styles1.odErrorTitle} `}>No Circulars Found. Try to search circulars with relevant keywords</div>
        </div>

      </div>
    </>

    return noItemFoundJSX;
  }

  private _getKey(item: any, index?: number): string {
    return item?.key;
  }

  private _onItemInvoked(item: any): void {
  }

  private _onRenderRow: IDetailsListProps['onRenderRow'] = props => {
    const customStyles: Partial<IDetailsRowStyles> = {};
    if (props) {
      if (props.itemIndex % 2 === 0) {
        customStyles.root = { backgroundColor: '#fff' };
        customStyles.fields = { lineHeight: 25 }
      }
      else {
        customStyles.root = { background: "#e9ecef7a" };
        customStyles.fields = { lineHeight: 25 }
      }
      return <DetailsRow {...props} styles={customStyles} />;
    }
    return null;
  }


  private createPagination = (): JSX.Element => {
    const { items, currentPage, itemsPerPage, filteredItems } = this.state;
    let providerContext = this.context;
    const { responsiveMode } = providerContext as IBobCircularRepositoryProps;
    const totalItems = filteredItems.length;
    const _themeWindow: any = window;
    const _theme = _themeWindow.__themeState__.theme;
    let isMobileMode = responsiveMode == 0 || responsiveMode == 1 || responsiveMode == 2;
    let lastItemCount = ((itemsPerPage * (currentPage - 1)) + itemsPerPage) > filteredItems.length ? filteredItems.length : ((itemsPerPage * (currentPage - 1)) + itemsPerPage)
    let pagination: any =
      <>
        <div className={`${styles.paginationContainer} ${styles1.row} `}>

          <div className={`${styles1.column4} `} style={{ padding: isMobileMode ? 0 : `inherit` }}>
            {/* {<Label>{JSON.stringify(theme.palette)}</Label>} */}
            {/* {<Label>{JSON.stringify(_theme)}</Label>} */}
            {<Label styles={{
              root: {
                paddingTop: 20,
                textAlign: "left",
                fontSize: isMobileMode ? 11 : 14,
                paddingLeft: 15,
                fontFamily: 'Roboto'
              }
            }}>
              {filteredItems.length > 0
                &&
                `Showing ${(itemsPerPage * (currentPage - 1) + 1)} to ${lastItemCount} of ${totalItems} `
              }
            </Label>}
          </div>
          <div className={`${styles.searchWp__paginationContainer__pagination} ${styles1.column8} `} style={{ padding: isMobileMode ? 0 : `inherit` }}>
            {filteredItems.length > 0 &&
              <Pagination
                activePage={currentPage}
                firstPageText={<Icon iconName="DoubleChevronLeftMed"
                  styles={{ root: { color: _theme.themePrimary, fontWeight: 600 } }}
                ></Icon>}
                lastPageText={<Icon iconName="DoubleChevronRight" styles={{ root: { color: _theme.themePrimary, fontWeight: 600 } }}></Icon>}
                prevPageText={<Icon iconName="ChevronLeft" styles={{ root: { color: _theme.themePrimary, fontWeight: 600 } }}></Icon>}
                nextPageText={<Icon iconName="ChevronRight" styles={{ root: { color: _theme.themePrimary, fontWeight: 600 } }} ></Icon>}
                activeLinkClass={`${styles.active} `}
                itemsCountPerPage={itemsPerPage}
                totalItemsCount={totalItems}
                pageRangeDisplayed={5}
                onChange={this.handlePageChange.bind(this)} />
            }
          </div>
        </div>
      </>;
    return pagination
  }


  private formatDate(dateStr: string): string {
    const date = new Date(dateStr);
    const month = (date.getMonth() + 1 < 10 ? '0' : '') + (date.getMonth() + 1);
    const day = (date.getDate() < 10 ? '0' : '') + date.getDate();
    const year = date.getFullYear().toString();
    let hour = date.getHours();
    const ampm = hour >= 12 ? 'pm' : 'am';
    hour = hour % 12;
    hour = hour ? hour : 12;
    const minute = (date.getMinutes() < 10 ? '0' : '') + date.getMinutes();

    const dateString = `${day} -${month} -${year} `;
    const dateParts: any[] = dateString.split("-");

    // create a new Date object with the year, month, and day
    const dateObject = new Date(dateParts[2], dateParts[1] - 1, dateParts[0]);

    // format the date as a string using the desired format
    const formattedDate = dateObject.toLocaleDateString("en-UK", { day: "2-digit", month: "short", year: "numeric" });

    return `${formattedDate} `;
  }

  private createHyper(item: any): JSX.Element {
    const name = item?.Subject;
    // const dateCreatedToCheck = new Date(item.Created).toLocaleDateString("en-US", { year: "numeric", month: "2-digit", day: "2-digit" });
    // const modifiedDateCheck = new Date(item.ModifiedDate).toLocaleDateString("en-US", { year: "numeric", month: "2-digit", day: "2-digit" });

    // const isTwoDaysBackCreated = this.checkThreeDaysBack(dateCreatedToCheck);
    // const isTwoDaysBackModified = this.checkThreeDaysBack(modifiedDateCheck);
    return (
      <>

        <div className={styles.viewList}>
          {/* {isTwoDaysBack && <Icon iconName='FavoriteStarFill' styles={{ root: { color: "gold", paddingRight: 5 } }}></Icon>} */}
          {/* <Image src={require(`../../ assets / newBell.gif`)}>
            
          </Image> */}

          <a onClick={this.readItemsAsStream.bind(this, item)}>{name}
            <Icon iconName="OpenInNewTab"></Icon>
          </a>

          {/* {isTwoDaysBackCreated && isTwoDaysBackModified &&
            <Badge appearance="filled" color="warning">
              New
            </Badge>}

          {isTwoDaysBackModified && !isTwoDaysBackCreated &&
            <Badge appearance="filled" color="success">
              Updated
            </Badge>} */}

        </div>
      </>
    )
  }


  private renderTextField(item: any): JSX.Element {
    const category = item?.DocumentCategory?.Title;
    // const { documentCategoryDD } = this.state
    // const itemColor = documentCategoryDD.filter((val) => {
    //   return val.name == category
    // })
    // console.log(item.DocumentCategory?.FontColor + ":" + item.DocumentCategory?.BackgroundColor)
    return (
      <>
        <span style={{
          whiteSpace: "break-spaces",
          textAlign: "center", display: "block",
          //color: itemColor[0]?.color,//item.DocumentCategory?.FontColor ?? `black`
          //background: itemColor[0]?.backgroundColor,// item.DocumentCategory?.BackgroundColor ?? `white`,
          borderRadius: 15,
          fontWeight: 600
        }}>{category}</span>
      </>
    )
  }


  private renderDate(item: any): JSX.Element {
    const dateVal = this.formatDate(item.PublishedDate)
    return (
      <>
        <span style={{ textAlign: 'center', display: "inherit" }}>{item.PublishedDate != null ? dateVal : ``}</span>
      </>
    )
  }


  private readItemsAsStream(item) {
    let providerContext = this.context;
    const { services, serverRelativeUrl } = providerContext as IBobCircularRepositoryProps;

    this.setState({ isLoading: true }, async () => {
      await services.getListDataAsStream(serverRelativeUrl, Constants.circularList, item.Id).then((result) => {
        console.clear();
        result.ListData.ID = item.Id;
        this.setState({ isLoading: false, previewItems: result.ListData })
      }).catch((error) => {
        console.log(error);
        this.setState({ isLoading: false })
      })
    })
  }

  public renderOwners(item: any): JSX.Element {
    const firstOwn = item?.PublisherEmailID;// item.Author.Title;
    return (<>
      {/* <Persona
        text={firstOwn}
        size={PersonaSize.size24}>
      </Persona> */}
      <span style={{ whiteSpace: "break-spaces" }}>{firstOwn}</span>
    </>)
  }

  private workingOnIt = (): JSX.Element => {

    let submitDialogJSX = <>
      <Dialog modalType="alert" defaultOpen={true}>
        <DialogSurface style={{ maxWidth: 250 }}>
          <DialogBody style={{ display: "block" }}>
            <DialogContent>
              {<Spinner labelPosition="below" label={"Working on It..."}></Spinner>}
            </DialogContent>
          </DialogBody>
        </DialogSurface>
      </Dialog>
    </>;
    return submitDialogJSX;
  }


  private handlePageChange(pageNo) {
    this.setState({ currentPage: pageNo });
  }

  private clearFilters = () => {

    this.setState({
      searchText: ``,
      selectedDepartment: [],
      circularNumber: ``,
      publishedStartDate: null,
      publishedEndDate: null,

    })

  }
}



---------------------------------------File Viewer-----------------------------


{/* {!isMobileMode &&
                                        <div className={`${styles.row} ${styles.marginTop} ${styles.marginBottom}`}>
                                            
                                            <div className={`${styles.column12} ${styles.textAlignEnd}`}>
                                                <DefaultButton iconProps={{ iconName: "PageLink" }} text='Copy Link'
                                                    onClick={() => { this.copyItemLink(listItem.ID) }}
                                                    styles={{
                                                        root: {
                                                            marginRight: 5,
                                                            boxShadow: "0 3px 10px rgb(0 0 0 / 40%)"
                                                        }
                                                    }}>
                                                </DefaultButton>
                                                {isAllowedToUpdate && <PrimaryButton text='Update' onClick={() => { this.onUpdateclick(listItem.ID) }}
                                                    iconProps={{ iconName: "Up" }}
                                                    allowDisabledFocus styles={{
                                                        root: {
                                                            padding: "0px!important",
                                                            boxShadow: "0 3px 10px rgb(0 0 0 / 40%)"
                                                        }
                                                    }}></PrimaryButton>
                                                }

                                            </div>
                                        </div>
                                    } */}

                                    {/* <div className={`${styles.row} ${styles.borderTop}`}>

                                        {this.labelControl(`${styles.column4} ${styles.displayBlock}`, `${Constants.fieldSubject}`, false)}
                                        {this.labelControl(`${styles.column8} ${styles.displayBlock}`, `${listItem.Subject}`, false)}
                                    </div>
                                    <div className={`${styles.row} ${styles.rowDetails}`}>
                                        {this.labelControl(`${styles.column4} ${styles.displayBlock}`, `${Constants.fieldCircularNumber}`, false)}
                                        {this.labelControl(`${styles.column8} ${styles.displayBlock}`, `${listItem.CircularNumber}`, false)}
                                    </div>

                                    <div className={`${styles.row}`}>

                                        {this.labelControl(`${styles.column4} ${styles.displayBlock}`, `${Constants.fieldDepartment}`, false)}
                                        {this.labelControl(`${styles.column8} ${styles.displayBlock}`, `${listItem.MigratedDepartment}`, false)}
                                    </div>
                                    <div className={`${styles.row} ${styles.rowDetails}`}>
                                        {this.labelControl(`${styles.column4} ${styles.displayBlock}`, `${Constants.fieldCircularStatus}`, false)}
                                        {this.labelControl(`${styles.column8} ${styles.displayBlock}`, `${listItem.CircularStatus}`, false)}
                                    </div>
                                    <div className={`${styles.row}`}>
                                        {this.labelControl(`${styles.column4} ${styles.displayBlock}`, `${Constants.fieldPublishedDate}`, false)}
                                        {this.labelControl(`${styles.column8} ${styles.displayBlock}`, `${this.convertDate(listItem.PublishedDate?.split(' ')[0])}`, false)}
                                    </div>
                                    <div className={`${styles.row} ${styles.rowDetails}`}>

                                        {this.labelControl(`${styles.column4} ${styles.displayBlock}`, `${Constants.fieldClassification}`, false)}
                                        {this.labelControl(`${styles.column8} ${styles.displayBlock}`, `${listItem.Classification}`, false)}
                                    </div> */}
                                    {/* <div className={`${styles.row} `}>
                                        {this.labelControl(`${styles.column4} ${styles.displayBlock}`, `FY`, false)}
                                        {this.labelControl(`${styles.column8} ${styles.displayBlock}`, `${listItem.FinancialYear}`, false)}
                                    </div>
                                    <div className={`${styles.row} ${styles.rowDetails}`}>
                                        {this.labelControl(`${styles.column4} ${styles.displayBlock}`, `${Constants.createdDate}`, false)}
                                        {this.labelControl(`${styles.column8} ${styles.displayBlock}`, `${this.convertDate(listItem.PublisherDate?.split(' ')[0])}`, false)}
                                    </div>
                                    <div className={`${styles.row} `}>
                                        {this.labelControl(`${styles.column4} ${styles.displayBlock}`, `${Constants.modifiedDate}`, false)}
                                        {this.labelControl(`${styles.column8} ${styles.displayBlock}`, `${this.convertDate(listItem.ModifiedDate?.split(' ')[0])}`, false)}
                                    </div>
                                    <div className={`${styles.row} ${styles.rowDetails}`}>
                                        {this.labelControl(`${styles.column4} ${styles.displayBlock}`, `${Constants.keywords}`, false)}
                                        {this.labelControl(`${styles.column8} ${styles.displayBlock}`, `${listItem.Keywords}`, false)}
                                    </div> */}
                                    {/* <div className={`${styles.row} ${styles['border-bottom']}`}>
                                        {this.labelControl(`${styles.column4} ${styles.displayBlock}`, `${Constants.references}`, false)}
                                        {<div className={`${styles.column8} ${styles.displayBlock}`}>
                                            {references.length > 0 && references.map((val) => {
                                                return <>
                                                    <Link onClick={() => { window.open(val.LinkReference, "_blank") }}
                                                        styles={{
                                                            root:
                                                                { wordBreak: "break-all" }
                                                        }}
                                                    >{val.LinkName}</Link>
                                                    <br />
                                                </>
                                            })
                                            }
                                        </div>
                                        }
                                        
                                    </div > */}

                                    {/* <div className={`${styles.row} `}>

                                        <div className={`${styles.column12}`}><Label>Circular Content</Label></div>
                                    </div> */}

                                    {/* <div className={`${styles.row} `}>
                                        {choiceGroup && choiceGroup.length > 0 &&
                                            choiceGroup.map((val, index) => {
                                                let selectedClass = selectedFile == val.key ? styles.attachments : styles.cursor;
                                                return <>
                                                    <div className={`${styles.column1}`}>
                                                        <Attach16Filled></Attach16Filled>
                                                    </div>
                                                    <div className={`${styles.column11} ${selectedClass}`}
                                                        onClick={this.onAttachmentClick.bind(this, index, val.key)}>
                                                        <Link title={`${val.key}`} styles={{
                                                            root: {
                                                                fontFamily: 'Roboto !important',
                                                                wordBreak: "break-all"
                                                            }
                                                        }}>{val.text}</Link>
                                                    </div >
                                                </>
                                            })

                                        }
                                    </div> */}

                                    {/* <IconButton iconProps={{ iconName: "FullScreen", styles: { root: { fontSize: 24 } } }}

                                                    title='Full Screen'
                                                    onClick={() => { this.onViewDownloadClick(selectedFile, true) }}></IconButton>
                                                <IconButton iconProps={{ iconName: "DownloadDocument", styles: { root: { fontSize: 24 } } }}
                                                    title='Download File'

                                                    onClick={() => { this.onViewDownloadClick(selectedFile, false) }}></IconButton> */}

                                                {/* {!isMobileMode &&
                                                    <IconButton iconProps={{ iconName: "Installation", styles: { root: { fontSize: 24 } } }}
                                                        title='Download All'
                                                        onClick={() => { this.onDownloadAllZip(listItem.ID, listItem.Subject) }}>

                                                    </IconButton>
                                                } */}

                                                {/* <ActionButton iconProps={{ iconName: "Print" }}></ActionButton> */}

                                                  {/* <PDF
                    file={`${this.props.pdfFilePath}`}
                    page={this.state.page}
                    watermark={this.props.watermarkText}
                    watermarkOptions={{
                        transparency: 0.5,
                        fontSize: 55,
                        fontStyle: 'Bold',
                        fontFamily: 'Arial'
                    }}
                    onDocumentComplete={() => {  }}
                    onPageRenderComplete={(pages, page) => this.setState({ page, pages })}
                /> */}
                {/* {pagination} */}

case `${Constants.lblContains}`:
        this.setState({ checkCircularRefiner: labelName, circularRefinerOperator: `` });
        break;
      case `${Constants.lblStartsWith}`: checkBoxCollection.set(`${Constants.circularNumber}`, {
        isContainsChecked: false,
        isStartsWithChecked: true,
        isEndsWithChecked: false
      });
        this.setState({ checkCircularRefiner: labelName, circularRefinerOperator: `starts-with` });
        break;
      case `${Constants.lblEndsWith}`:
        checkBoxCollection.set(`${Constants.circularNumber}`, {
          isContainsChecked: false,
          isStartsWithChecked: false,
          isEndsWithChecked: true
        });
        this.setState({ checkCircularRefiner: labelName, circularRefinerOperator: `ends-with` });
        break;
      case `${Constants.lblMaster}`:
        checkBoxCollection.set(`${Constants.classification}`, [
          {
            checked: false,
            value: "Master",
            refinableString: "RefinableString06"
          },
          {
            checked: false,
            value: "Circular",
            refinableString: "RefinableString06"
          }
        ]);
        checkBoxCollection.set(`${Constants.classification}`, {
          isMasterChecked: !classificationBox.isMasterChecked,
          isCircularChecked: classificationBox.isCircularChecked
        });
        this.setState({ checkCircularRefiner: labelName, checkBoxCollection });
        break;
      case `${Constants.lblCircular}`:
        checkBoxCollection.set(`${Constants.classification}`, {
          isMasterChecked: classificationBox.isMasterChecked,
          isCircularChecked: !classificationBox.isCircularChecked
        });
        this.setState({ checkCircularRefiner: labelName, checkBoxCollection });
        break;
      case `${Constants.lblComplianceYes}`:
        checkBoxCollection.set(`${Constants.compliance}`, {
          isYesChecked: !regulatoryBox.isYesChecked,
          isNoChecked: regulatoryBox.isNoChecked
        });
        this.setState({ checkCircularRefiner: labelName, checkBoxCollection });
        break;
      case `${Constants.lblComplianceNo}`:
        checkBoxCollection.set(`${Constants.compliance}`, {
          isYesChecked: regulatoryBox.isYesChecked,
          isNoChecked: !regulatoryBox.isNoChecked
        });
        this.setState({ checkCircularRefiner: labelName, checkBoxCollection });
        break;
      case `${Constants.lblIndia}`:
        checkBoxCollection.set(`${Constants.issuedFor}`, {
          isIndiaChecked: !issuedForBox.isIndiaChecked,
          isGlobalChecked: issuedForBox.isGlobalChecked
        })
        this.setState({ checkCircularRefiner: labelName, checkBoxCollection });
        break;
      case `${Constants.lblGlobal}`:
        checkBoxCollection.set(`${Constants.issuedFor}`, {
          isIndiaChecked: issuedForBox.isIndiaChecked,
          isGlobalChecked: !issuedForBox.isGlobalChecked
        })
        this.setState({ checkCircularRefiner: labelName, checkBoxCollection });
        break;
      case `${Constants.lblIntimation}`:
        checkBoxCollection.set(`${Constants.category}`, {
          isIntimationChecked: !categoryBox.isIntimationChecked,
          isInformationChecked: categoryBox.isInformationChecked,
          isActionChecked: categoryBox.isActionChecked
        })

        this.setState({ checkCircularRefiner: labelName, checkBoxCollection });
        break;
      case `${Constants.lblInformation}`:
        checkBoxCollection.set(`${Constants.category}`, {
          isIntimationChecked: categoryBox.isIntimationChecked,
          isInformationChecked: !categoryBox.isInformationChecked,
          isActionChecked: categoryBox.isActionChecked
        })
        this.setState({ checkCircularRefiner: labelName, checkBoxCollection });
        break;
      case `${Constants.lblAction}`:
        checkBoxCollection.set(`${Constants.category}`, {
          isIntimationChecked: categoryBox.isIntimationChecked,
          isInformationChecked: categoryBox.isInformationChecked,
          isActionChecked: !categoryBox.isActionChecked
        })

        this.setState({ checkCircularRefiner: labelName, checkBoxCollection });
        break;